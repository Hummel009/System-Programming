Мои лабораторные работы для BSUIR/БГУИР (белорусский государственный университет информатики и радиоэлектроники).

Предмет - SP/СП (системное программирование).

## Общая информация
Каждая папка в репозитории - это отдельный проект.

* Lab01, Lab02 - это проекты Gradle, которые должны быть открыты через IntelliJ IDEA или импортирован в Eclipse IDE с плагином Kotlin.
  * Используемая версия Gradle - 8.4.
  * Используемая версия Kotlin - 1.9.20.
  * Используемая версия JDK - Eclipse Temurin 1.8.0_392.
* Lab03 - это набор папок, не предназначенных для запуска из сред программирования.
  * Каждая подпапка содержит в себе решение одного пункта задания. Задание запускается bat-файлом.
  * Используемый язык - C++
  * Используемая версия компилятора GCC - 10.3.0.
* Lab04, CourseNative - это проекты Gradle, которые должны быть открыты через IntelliJ IDEA.
  * Используемая версия Gradle - 8.4.
  * Используемая версия Kotlin Native - 1.9.20.
  * Используемая версия JDK - Eclipse Temurin 1.8.0_392.
  * Используемая платформа - Windows.
* CourseFX - это проект Gradle, который должен быть открыт через IntelliJ IDEA или импортирован в Eclipse IDE с плагином Kotlin.
  * Используемая версия Gradle - 8.4.
  * Используемая версия Kotlin - 1.9.20.
  * Используемая версия JDK - Eclipse Temurin 17.0.8.

## Условия работ

Каждая работа использует Windows API для работы с Windows.

### Лабораторная работа 1

Изучение событийной архитектуры Windows-приложений, механизмы обработки сообщений, механизмы перерисовки окна.

* Разработать программу, позволяющую передвигать с помощью клавиатуры и мыши спрайт (или геометрическую фигуру) внутри рабочей области окна.
* Обеспечить работу колёсика мыши (движение по вертикали, если shift – по горизонтали).
* Придать спрайту движение с отскоком от границ окна.
* Задействовать хотя бы одну горячую клавишу (ctrl + <smth>) с использованием таблиц акселерации.

Программа реализована на языке Kotlin с использованием JNA (Java Native Access). Для доступа к функциям WinAPI я писал свои обёртки, расположенные в логично названных классах.

### Лабораторная работа 2

Изучение вывода текста и шрифтов.

* Разработать программу, которая вписывает в окно текстовую таблицу N строк на M столбцов таким образом, что все столбцы таблицы равномерно распределяются по ширине окна, а высота строк таблицы подбирается таким образом, чтобы вместить текст каждой ячейки.
* При изменении размеров окна таблица пересчитывается и перерисовывается.
* Вписать текст в окружность так, чтобы он выглядел, как на печати.

Программа реализована на языке Kotlin с использованием JNA (Java Native Access). Для доступа к функциям WinAPI я писал свои обёртки, расположенные в логично названных классах.

### Лабораторная работа 3

Изучение создания использования динамических загружаемых библиотек DLL.

* Разработать программу, которая выполняет Runtime импорт DLL и вызывает её функцию.
* Разработать программу, которая выполняет Loadtime импорт DLL и вызывает её функцию.
* Разработать DLL с функцией поиска заданной строки по всей виртуальной памяти и замены этой строки на другую.
* Разработать программу, которая внедряет DLL в заданный процесс и вызывает её функцию.

Программа реализована на языке C++. 

### Лабораторная работа 4

Изучение работы с реестром. Разработать программу, которая демонстрирует следующий функционал:

* Создание ключа, открытие ключа, закрытие ключа, удаление ключа, замена содержимого ключа.
* Вывод флагов ключа.
* Отслеживание изменения ключа.

Программа реализована на языке Kotlin Native под платформу Windows.

### Лабораторная работа 5

Изучение, создание и использование потоков и механизмов синхронизации.

* Разработать очередь заданий, в которой несколько потоков могут вставлять элементы атомарно.
* Разработать обработчик этой очереди, который извлекает из неё задания и раздаёт заданному количеству потоков.
* Разработать программу, которая использует очередь заданий и обработчик очереди для сортировки строк в .txt файле:
  * Входной поток читает файл в память, нарезает его на части и создаёт несколько заданий на сортировку по числу сортирующих потоков.
  * Входной поток помещает их в очередь заданий.
  * Сортирующие потоки извлекают задание, сортируют свои части файла, отдают результаты выходному потоку.
  * Выходной поток ждёт все сортирующие части и мержит их методом сортирующего слияния.
